ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Compartment", type = "qual", palette = 6) +
ggplot2::scale_y_continuous(trans = "sqrt",
breaks = c(0,50, 250, 1000, 2.5e3, 5e3,7.5e3,1e4),
expand = c(0,0)) +
ggplot2::labs(title = "", subtitle = "ODE")
ode_incid =
ggplot2::ggplot(subset(sim_paths, Method == "ODE" & Type == "Incidence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_point(shape = 3) +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Transition", type = "qual", palette = 2) +
ggplot2::labs(title = "", subtitle = "ODE")
(mjp_counts + lna_prev + ode_prev) /
(mjp_incid + lna_incid + ode_incid)
ggplot2::ggplot(data = as.data.frame(sim_mjp$datasets[[1]]),
ggplot2::aes(x=time, y = I)) +
ggplot2::geom_point() +
ggplot2::theme_minimal() +
ggplot2::labs(x = "Week", y = "Count", title = "Observed Incidence")
ggplot2::ggplot(data = as.data.frame(sim_ode$datasets[[1]]),
ggplot2::aes(x=time, y = I)) +
ggplot2::geom_point() +
ggplot2::theme_minimal() +
ggplot2::labs(x = "Week", y = "Count", title = "Observed Incidence")
ggplot2::ggplot(data = as.data.frame(sim_lna$datasets[[1]]),
ggplot2::aes(x=time, y = I)) +
ggplot2::geom_point() +
ggplot2::theme_minimal() +
ggplot2::labs(x = "Week", y = "Count", title = "Observed Incidence")
sim_mjp$datasets[[1]]
measurement_process <-
stem_measure(emissions = emissions,
dynamics = dynamics,
data = sim_mjp$datasets[[1]])
sim_mjp$datasets[[1]]
tmax
measurement_process <-
stem_measure(emissions = emissions,
dynamics = dynamics,
data = sim_ode$datasets[[1]])
library(stemr)
library(patchwork)
library(ggplot2)
popsize = 764 # population size
true_pars =
c(R0     = 0.5*1/0.1,  # basic reproduction number
mu_inv = 1/0.1,    # infectious period duration = 2 days
rho    = 0.5,  # case detection rate
phi    = 10)   # negative binomial overdispersion
# initialize model compartments and rates
strata <- NULL # no strata
compartments <- c("S", "I", "R")
# rates initialized as a list of rate lists
rates <-
list(rate(rate = "beta * I", # individual level rate (unlumped)
from = "S",        # source compartment
to   = "I",        # destination compartment
incidence = T),    # compute incidence of S2I transitions, required for simulating incidence data
rate(rate = "mu",       # individual level rate
from = "I",        # source compartment
to   = "R",        # destination compartment
incidence = T)) # compute incidence of I2R transitions (not required for simulating data)
# list used for simulation/inference for the initial state, initial counts fixed.
# state initializer a list of stem_initializer lists.
state_initializer <-
list(stem_initializer(
init_states = c(S = popsize-1, I = 1, R = 0), # must match compartment names
fixed = T)) # initial state fixed for simulation, we'll change this later
# set the parameter values - must be a named vector
parameters =
c(true_pars["R0"] / popsize / true_pars["mu_inv"], # R0 = beta * P / mu
1/true_pars["mu_inv"],
true_pars["rho"],
true_pars["phi"])
names(parameters) <- c("beta", "mu", "rho", "phi")
# declare the initial time to be constant
constants <- c(t0 = 0)
t0 <- 0; tmax <- 40
# compile the model
dynamics <-
stem_dynamics(
rates = rates,
tmax = tmax,
parameters = parameters,
state_initializer = state_initializer,
compartments = compartments,
constants = constants,
compile_ode = T,   # compile ODE functions
compile_rates = T, # compile MJP functions for Gillespie simulation
compile_lna = T,   # compile LNA functions
messages = F       # don't print messages
)
# list of emission distribution lists (analogous to rate specification)
emissions <-
list(emission(meas_var = "S2I", # transition or compartment being measured (S->I transitions)
distribution    = "negbinomial",         # emission distribution
emission_params = c("phi", "S2I * rho"), # distribution pars, here overdispersion and mean
incidence       = TRUE,                  # is the data incidence
obstimes        = seq(1, tmax, by = 1)))  # vector of observation times
# compile the measurement process
measurement_process <-
stem_measure(emissions = emissions,
dynamics  = dynamics,
messages  = F)
# put it all together into a stochastic epidemic model object
stem_object <-
make_stem(dynamics = dynamics,
measurement_process = measurement_process)
sim_mjp <- simulate_stem(stem_object = stem_object, method = "gillespie", full_paths = T)
sim_lna <- simulate_stem(stem_object = stem_object, method = "lna", lna_method = "approx")
sim_ode <- simulate_stem(stem_object = stem_object, method = "ode")
sim_paths =
expand.grid(time = 0:tmax,
Method = c("Gillespie", "LNA", "ODE"),
Compartment = c("S","I","R","S2I","I2R"),
Type = c("Prevalence","Incidence"))
sim_paths =
sim_paths[!((
sim_paths$Compartment %in% c("S", "I", "R") &
sim_paths$Type == "Incidence") |
(sim_paths$Compartment %in% c("S2I", "I2R") &
sim_paths$Type == "Prevalence")), ]
sim_paths$Compartment = factor(sim_paths$Compartment, levels = c("S", "I", "R", "S2I", "I2R"))
sim_paths = sim_paths[with(sim_paths, order(Method, Compartment, Type, time)), ]
sim_paths$Count =
c(
sim_mjp$paths[[1]][, -1],
sim_lna$natural_paths[[1]][, -1],
sim_lna$paths[[1]][, -1],
sim_ode$natural_paths[[1]][, -1],
sim_ode$paths[[1]][, -1]
)
mjp_prev =
data.frame(time = sim_mjp$full_paths[[1]][,1],
Compartment = rep(c("S","I","R"), each = nrow(sim_mjp$full_paths[[1]])),
Count = c(sim_mjp$full_paths[[1]][,3:5]))
mjp_counts =
ggplot2::ggplot(mjp_prev,
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_step() +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer(type = "qual", palette = 6) +
ggplot2::scale_y_continuous(trans = "sqrt",
breaks = c(0,50, 250, 1000, 2.5e3, 5e3,7.5e3,1e4),
expand = c(0,0)) +
ggplot2::labs(title = "Compartment counts", subtitle = "MJP")
mjp_incid =
ggplot2::ggplot(subset(sim_paths, Method == "Gillespie" & Type == "Incidence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_point() +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Transition", type = "qual", palette = 2) +
ggplot2::labs(title = "Incident transition events",subtitle = "MJP")
lna_prev =
ggplot2::ggplot(subset(sim_paths, Method == "LNA" & Type == "Prevalence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_line(linetype = 2) +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Compartment", type = "qual", palette = 6) +
ggplot2::scale_y_continuous(trans = "sqrt",
breaks = c(0,50, 250, 1000, 2.5e3, 5e3,7.5e3,1e4),
expand = c(0,0)) +
ggplot2::labs(title = "", subtitle = "LNA")
lna_incid =
ggplot2::ggplot(subset(sim_paths, Method == "LNA" & Type == "Incidence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_point(shape = 2) +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Transition", type = "qual", palette = 2) +
ggplot2::labs(title = "",subtitle = "LNA")
ode_prev =
ggplot2::ggplot(subset(sim_paths, Method == "ODE" & Type == "Prevalence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_line(linetype = 3) +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Compartment", type = "qual", palette = 6) +
ggplot2::scale_y_continuous(trans = "sqrt",
breaks = c(0,50, 250, 1000, 2.5e3, 5e3,7.5e3,1e4),
expand = c(0,0)) +
ggplot2::labs(title = "", subtitle = "ODE")
ode_incid =
ggplot2::ggplot(subset(sim_paths, Method == "ODE" & Type == "Incidence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_point(shape = 3) +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Transition", type = "qual", palette = 2) +
ggplot2::labs(title = "", subtitle = "ODE")
(mjp_counts + lna_prev + ode_prev) /
(mjp_incid + lna_incid + ode_incid)
ggplot2::ggplot(data = as.data.frame(sim_mjp$datasets[[1]]),
ggplot2::aes(x=time, y = S2I)) +
ggplot2::geom_point() +
ggplot2::theme_minimal() +
ggplot2::labs(x = "Week", y = "Count", title = "Observed Incidence")
measurement_process <-
stem_measure(emissions = emissions,
dynamics = dynamics,
data = sim_mjp$datasets[[1]])
stem_object <-
make_stem(dynamics = dynamics,
measurement_process = measurement_process)
## Parameterization in terms of log(R0) and log(mu)
## Priors for log(R0), log(mu), logit(rho), phi
# Parameters (natural scale): beta, mu, rho, phi
# Parameters (estimation scale): log(beta * N / mu), log(mu), logit(rho), log(phi)
# function to take params_nat and return params_est
to_estimation_scale = function(params_nat) {
c(log(params_nat[1] * popsize / params_nat[2] - 1), # (beta,mu,N) -> log(R0-1)
log(params_nat[2]),                     # mu -> log(mu)
logit(params_nat[3]),                   # rho -> logit(rho)
log(params_nat[4]))                     # phi -> log(phi)
}
# function to take params_est and return params_nat
from_estimation_scale = function(params_est) {
c(exp(log(exp(params_est[1])+1) + params_est[2] - log(popsize)), # (log(R0), log(mu), N) -> beta = exp(log(R0) + log(mu) - log(N))
exp(params_est[2]), # log(mu) -> mu
expit(params_est[3]), # logit(rho) -> rho
exp(params_est[4])) # log(phi) -> phi
}
# calculate the log prior density. note the jacobian for phi
logprior =
function(params_est) {
sum(dnorm(params_est[1],  0, 0.5, log = TRUE),
dnorm(params_est[2], -2, 0.35, log = TRUE),
dnorm(params_est[3],  0, 1, log = TRUE),
dexp(exp(params_est[4]), 0.1, log = TRUE) + params_est[4])
}
# return all three functions in a list
priors <- list(logprior = logprior,
to_estimation_scale = to_estimation_scale,
from_estimation_scale = from_estimation_scale)
par_initializer = function() {
priors$from_estimation_scale(priors$to_estimation_scale(parameters) +
rnorm(4, 0, 0.1))
}
# specify the kernel
mcmc_kern <-
mcmc_kernel(
parameter_blocks =
list(parblock(
pars_nat = c("beta", "mu", "rho", "phi"),
pars_est = c("log_R0", "log_mu", "logit_rho", "log_phi"),
priors = priors,
alg = "mvnmh",
sigma = diag(0.01, 4),
initializer = par_initializer,
control =
mvnmh_control(stop_adaptation = 2.5e2))),
lna_ess_control = lna_control(bracket_update_iter = 50))
res <-
fit_stem(stem_object = stem_object,
method = "lna",
mcmc_kern = mcmc_kern,
thinning_interval = 5,
iterations = 5e2)
runtime = res$results$runtime
posterior = res$results$posterior # list with posterior objects
posterior$parameter_samples_nat
library(stemr)
library(patchwork)
library(ggplot2)
popsize = 764 # population size
true_pars =
c(R0     = 0.5*1/0.1,  # basic reproduction number
mu_inv = 1/0.1,    # infectious period duration = 2 days
q    = 0.5)  # case detection rate
# initialize model compartments and rates
strata <- NULL # no strata
compartments <- c("S", "I", "R")
# rates initialized as a list of rate lists
rates <-
list(rate(rate = "beta * I", # individual level rate (unlumped)
from = "S",        # source compartment
to   = "I",        # destination compartment
incidence = T),    # compute incidence of S2I transitions, required for simulating incidence data
rate(rate = "mu",       # individual level rate
from = "I",        # source compartment
to   = "R",        # destination compartment
incidence = T)) # compute incidence of I2R transitions (not required for simulating data)
# list used for simulation/inference for the initial state, initial counts fixed.
# state initializer a list of stem_initializer lists.
state_initializer <-
list(stem_initializer(
init_states = c(S = popsize-1, I = 1, R = 0), # must match compartment names
fixed = T)) # initial state fixed for simulation, we'll change this later
# set the parameter values - must be a named vector
parameters =
c(true_pars["R0"] / popsize / true_pars["mu_inv"], # R0 = beta * P / mu
1/true_pars["mu_inv"],
true_pars["q"])
names(parameters) <- c("beta", "mu", "q")
# declare the initial time to be constant
constants <- c(t0 = 0)
t0 <- 0; tmax <- 40
# compile the model
dynamics <-
stem_dynamics(
rates = rates,
tmax = tmax,
parameters = parameters,
state_initializer = state_initializer,
compartments = compartments,
constants = constants,
compile_ode = T,   # compile ODE functions
compile_rates = T, # compile MJP functions for Gillespie simulation
compile_lna = T,   # compile LNA functions
messages = F       # don't print messages
)
# list of emission distribution lists (analogous to rate specification)
emissions <-
list(emission(meas_var = "I", # transition or compartment being measured (S->I transitions)
distribution    = "poisson",         # emission distribution
emission_params = c("I*q"), # distribution pars, here overdispersion and mean
incidence       = F,                  # is the data incidence
obstimes        = seq(1, tmax, by = 1)))  # vector of observation times
# compile the measurement process
measurement_process <-
stem_measure(emissions = emissions,
dynamics  = dynamics,
messages  = F)
# put it all together into a stochastic epidemic model object
stem_object <-
make_stem(dynamics = dynamics,
measurement_process = measurement_process)
sim_mjp <- simulate_stem(stem_object = stem_object, method = "gillespie", full_paths = T)
sim_lna <- simulate_stem(stem_object = stem_object, method = "lna", lna_method = "approx")
sim_ode <- simulate_stem(stem_object = stem_object, method = "ode")
sim_paths =
expand.grid(time = 0:tmax,
Method = c("Gillespie", "LNA", "ODE"),
Compartment = c("S","I","R","S2I","I2R"),
Type = c("Prevalence","Incidence"))
sim_paths =
sim_paths[!((
sim_paths$Compartment %in% c("S", "I", "R") &
sim_paths$Type == "Incidence") |
(sim_paths$Compartment %in% c("S2I", "I2R") &
sim_paths$Type == "Prevalence")), ]
sim_paths$Compartment = factor(sim_paths$Compartment, levels = c("S", "I", "R", "S2I", "I2R"))
sim_paths = sim_paths[with(sim_paths, order(Method, Compartment, Type, time)), ]
sim_paths$Count =
c(
sim_mjp$paths[[1]][, -1],
sim_lna$natural_paths[[1]][, -1],
sim_lna$paths[[1]][, -1],
sim_ode$natural_paths[[1]][, -1],
sim_ode$paths[[1]][, -1]
)
mjp_prev =
data.frame(time = sim_mjp$full_paths[[1]][,1],
Compartment = rep(c("S","I","R"), each = nrow(sim_mjp$full_paths[[1]])),
Count = c(sim_mjp$full_paths[[1]][,3:5]))
mjp_counts =
ggplot2::ggplot(mjp_prev,
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_step() +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer(type = "qual", palette = 6) +
ggplot2::scale_y_continuous(trans = "sqrt",
breaks = c(0,50, 250, 1000, 2.5e3, 5e3,7.5e3,1e4),
expand = c(0,0)) +
ggplot2::labs(title = "Compartment counts", subtitle = "MJP")
mjp_incid =
ggplot2::ggplot(subset(sim_paths, Method == "Gillespie" & Type == "Incidence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_point() +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Transition", type = "qual", palette = 2) +
ggplot2::labs(title = "Incident transition events",subtitle = "MJP")
lna_prev =
ggplot2::ggplot(subset(sim_paths, Method == "LNA" & Type == "Prevalence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_line(linetype = 2) +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Compartment", type = "qual", palette = 6) +
ggplot2::scale_y_continuous(trans = "sqrt",
breaks = c(0,50, 250, 1000, 2.5e3, 5e3,7.5e3,1e4),
expand = c(0,0)) +
ggplot2::labs(title = "", subtitle = "LNA")
lna_incid =
ggplot2::ggplot(subset(sim_paths, Method == "LNA" & Type == "Incidence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_point(shape = 2) +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Transition", type = "qual", palette = 2) +
ggplot2::labs(title = "",subtitle = "LNA")
ode_prev =
ggplot2::ggplot(subset(sim_paths, Method == "ODE" & Type == "Prevalence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_line(linetype = 3) +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Compartment", type = "qual", palette = 6) +
ggplot2::scale_y_continuous(trans = "sqrt",
breaks = c(0,50, 250, 1000, 2.5e3, 5e3,7.5e3,1e4),
expand = c(0,0)) +
ggplot2::labs(title = "", subtitle = "ODE")
ode_incid =
ggplot2::ggplot(subset(sim_paths, Method == "ODE" & Type == "Incidence"),
ggplot2::aes(x = time, y = Count,
colour = Compartment, group = Compartment)) +
ggplot2::geom_point(shape = 3) +
ggplot2::theme_minimal() +
ggplot2::scale_color_brewer("Transition", type = "qual", palette = 2) +
ggplot2::labs(title = "", subtitle = "ODE")
(mjp_counts + lna_prev + ode_prev) /
(mjp_incid + lna_incid + ode_incid)
# fitting
ggplot2::ggplot(data = as.data.frame(sim_mjp$datasets[[1]]),
ggplot2::aes(x=time, y = I)) +
ggplot2::geom_point() +
ggplot2::theme_minimal() +
ggplot2::labs(x = "Week", y = "Count", title = "Observed Incidence")
ggplot2::ggplot(data = as.data.frame(sim_ode$datasets[[1]]),
ggplot2::aes(x=time, y = I)) +
ggplot2::geom_point() +
ggplot2::theme_minimal() +
ggplot2::labs(x = "Week", y = "Count", title = "Observed Incidence")
ggplot2::ggplot(data = as.data.frame(sim_lna$datasets[[1]]),
ggplot2::aes(x=time, y = I)) +
ggplot2::geom_point() +
ggplot2::theme_minimal() +
ggplot2::labs(x = "Week", y = "Count", title = "Observed Incidence")
measurement_process <-
stem_measure(emissions = emissions,
dynamics = dynamics,
data = sim_ode$datasets[[1]])
stem_object <-
make_stem(dynamics = dynamics,
measurement_process = measurement_process)
## Parameterization in terms of log(R0) and log(mu)
## Priors for log(R0), log(mu), logit(rho), phi
# Parameters (natural scale): beta, mu, rho, phi
# Parameters (estimation scale): log(beta * N / mu), log(mu), logit(rho), log(phi)
# function to take params_nat and return params_est
to_estimation_scale = function(params_nat) {
c(log(params_nat[1] * popsize / params_nat[2] - 1), # (beta,mu,N) -> log(R0-1)
log(params_nat[2]),                     # mu -> log(mu)
logit(params_nat[3]))                   # q -> logit(q)
}
# function to take params_est and return params_nat
from_estimation_scale = function(params_est) {
c(exp(log(exp(params_est[1])+1) + params_est[2] - log(popsize)), # (log(R0), log(mu), N) -> beta = exp(log(R0) + log(mu) - log(N))
exp(params_est[2]), # log(mu) -> mu
expit(params_est[3])) # logit(q) -> q
}
# calculate the log prior density. note the jacobian for phi
logprior =
function(params_est) {
sum(dnorm(params_est[1],  0, 0.5, log = TRUE),
dnorm(params_est[2], -2, 0.35, log = TRUE),
dnorm(params_est[3],  0, 1, log = TRUE))
}
# return all three functions in a list
priors <- list(logprior = logprior,
to_estimation_scale = to_estimation_scale,
from_estimation_scale = from_estimation_scale)
par_initializer = function() {
priors$from_estimation_scale(priors$to_estimation_scale(parameters) +
rnorm(3, 0, 0.1))
}
# specify the kernel
mcmc_kern <-
mcmc_kernel(
parameter_blocks =
list(parblock(
pars_nat = c("beta", "mu", "q"),
pars_est = c("log_R0", "log_mu", "logit_q"),
priors = priors,
alg = "mvnmh",
sigma = diag(0.01, 3),
initializer = par_initializer,
control =
mvnmh_control(stop_adaptation = 2.5e2))),
lna_ess_control = lna_control(bracket_update_iter = 50))
res <-
fit_stem(stem_object = stem_object,
method = "ode",
mcmc_kern = mcmc_kern,
thinning_interval = 5,
iterations = 5e2)
setwd("D:/PythonDir/Postdoc/Michael/GithubRepo/PAL/RealDataExperiments/BSFLU")
load("D:/PythonDir/Postdoc/Michael/GithubRepo/PAL/RealDataExperiments/BSFLU/syntheticLNA_500.Rdata")
dev.off()
par(mar =c(1,5,1,1), mfrow = c(4,1))
ts.plot(mcmc_chain_real$param_samples[1,], ylab="beta")
ts.plot(mcmc_chain_real$param_samples[2,], ylab="gamma")
ts.plot(mcmc_chain_real$param_samples[3,], ylab="q")
ts.plot(mcmc_chain_real$param_samples[4,], ylab="v")
par(mfrow = c(4,1))
acf(mcmc_chain_real$param_samples[1,])
acf(mcmc_chain_real$param_samples[2,])
acf(mcmc_chain_real$param_samples[3,])
acf(mcmc_chain_real$param_samples[4,])
par( mfrow = c(4,1))
hist(mcmc_chain_real$param_samples[1,])
hist(mcmc_chain_real$param_samples[2,])
hist(mcmc_chain_real$param_samples[3,])
hist(mcmc_chain_real$param_samples[4,])
23.5/1.1676831
